# مرحله اول

## 1. تفاوت بین یک کامپوننت فانکشنال و کلاس کامپوننت چیست؟

   . ساختارشون مثلا در فاگشنال کمپوننت میتونیم از هوک ها استفاده کنیم ولی در کلاس  کمپوننت ها نه یا مثلا تابعی مثل فورس آپدیت در فاگشنال کمپوننت ها نیست. توی کلاس کمپوننت ها از this خیلی استفاده میشه.
    نوع تعریفشون فرق داره . در کلاس کمپوننت ها باید کلاسمون یک اکستند از Component در کتابخانه react باشه و در نهایت ریترنمون باید در تابع render باشه.
    اما در فاگشنال کمپوننت ها چنین ساختاری نداریم و ساختارش این توابع جاوا اسکریپت است.
    
   . (و آیا هنوز کلاس کامپوننت استفاده می‌شوند؟ چرا/چرا نه؟) </br>
	   در جواب این سوال میشه گفت خیر بعضی از برنامه نویس ها هنوز با این روش عادت دارن ولی بازم کلاس کمپوننت ها قدیمی محسوب میشن و پیشنهادم نمیشه ازش استفاده کرد چون ساختارش به مراتب پیچیده تر و سخت تر از فاگشنال کمپوننت هاست و توشون نمیشه از هوک ها استفاده کرد .
   

## 2. مفهوم Virtual DOM چیست و چرا مهم است؟
   . یک نسخه مجازی از دام واقعی که تو حافظه قرار گرفته میشه و در نهایت با دام اصلی مقایسه میشه و فقط تغییرات جدید روی دام اصلی اعمال میشه. چرا مهمه چون باعث افزایش سرعت و بهینه سازی رندر میشه.
    مثلا تو react بعد رندر virtual dom جدید ساخته میشه و بعد react یه مقایسه بین دام اصلی و مجازی انجام میده و فقط تغییرات اصلی رو روی دام اصلی اعمال میکنه.
   
  
## 3. تفاوت useState و useEffect در چیست؟ یک مثال کاربردی برای هرکدام بزن.
   . هوک **useState** قابلیت تعریف state در فاگشنال کمپوننت به ما میده که باهاش میتونیم یک وضعیت را ذخیره و اپدیت کنیم. ساختار:
  ```jsx
    
    import {useState} from 'react';
    export default function dood(){
    const [state,setState]=useState(0) //مقدار اولیه
    return (
    <button onClick={()=> setState(prevState=>prevState+1)}></button>
    )
    }
  ``` 
    
   . زمانی که setState رخ میده باعث رندر مجدد میشه.
    
   . هوک **useEffect** برای اجرای کدی بعد از رندر شدن کامپوننت به‌کار میره مثلا اگه بخواهیم یک دیتا یا چیزی رو از سمت api بگیریم. ساختار:
  ```jsx
    import {useEffect} from "react"
    export default function dood(){
    useEffect(()=>{
    console.log("good bay")
    return ()=>{} //تابع cleanup
    },[])//دپندنسی ها
    }
    console.log("hello");
    return (<div>Hello</div>);
  ```
    
   . این هوک بعد رندر بسته به dependency اجرا میشه اگه دپندنسی هاش خالی باشن فقط یک بار اجرا میشه.
   

## 4. کامپوننت‌های Controlled و Uncontrolled در فرم‌ها چه تفاوتی دارند؟
   . کامپوننت های Controlled در فرم ها مقدار input رو از state میگیره و هر تغییری از سمت setState کنترل میشه. (یعنی React به طور کامل کنترل ورودی رو در دست داره) مثال:
  ```jsx
    import {useState} from 'react';
    export default function dood(){
    const [state,setState]=useState('') //مقدار اولیه
    return (
    <input value={state} onChange={e=> setState(e.target.value)}></input>
    )
    }
  ```
   . اما کامپوننت های Uncontrolled در فرم ها مقدار ورودی مستقیما از DOM گرفته میشه و نه از state معمولا هم با استفاده از ref این کارو انجام میدن و این باعث میشه react بر مقدار ورودی کنترلی نداشته باشه و DOM واقعی مسئول نگه‌داری مقدار اینپوت هستش.
    

## 6. چطور از یک API داده دریافت می‌کنی و آن را در کامپوننت نمایش می‌دهی؟
   . با استفاده از useEffect و useState یا پکیج axios به این شکل:
  ```tsx
    import {useEffect,useState} from "react"
    export default function dood(){
    const [data,setData] = useState([])
    const [loading,setLoading] = useState(true)
    useEffect(()=>{
    fetch("https://jsonplaceholder.typicode.com/users")
    .then(r=>r.json())
    .then(i=>setData(i))
    .catch(e=>{console.log(e);setLoading(true)})
    .finally(()=>setLoading(false))
    })
    return (<>
    {!loading&&<div><ul>
        {users.map((user) => (
          <li key={user.id}>
            {user.name} :({user.email})
          </li>
        ))}
      </ul>
    </div>}
    </>)
    }
  ```
  . (مثلاً دریافت لیست کاربران) </br>
	 . چه هوک‌هایی استفاده می‌کنی؟ useEffect و useState <br/>
	 . با خطاهای HTTP چطور برخورد می‌کنی؟  ارور رو لاگ میگیرم. با axios مدیریت خطا خیلی راحت تره.
   

## 7. فرض کن باید با API یک کاربر را حذف کنی. روند کلی پیاده‌سازی آن را بگو.
   . اول در جایی که کاربرانو مپ میکنیم درون li بعلاوه اسم کاربر یک باتن delete اضافه میکنیم که موقعی که روش کلیک شد مقدار id  رو به تابع handleDelete پاس بده.
     تابع handleDelete:
  ```javascript
       function handleDelete (userId){
    fetch(`https://localhost/users/${userId}`, {
      method: 'DELETE',
    })
      .then((res) => {
        if (!res.ok) throw new Error('Error: Can not delete');
        //حذف اون کاربر از state
        setUsers((prevState) => prevState.filter((u) => u.id !== userId));
      })
      .catch((err) => alert(`${err.message}`));
  };
  ```
   . در UI:
```jsx
	{users.map(user => (
          <li key={user.id}>
            {user.name}
            <button onClick={() => handleDelete(user.id)}>
              delete
            </button>
          </li>
        ))}
```
    

## 7. تفاوت fetch و axios چیست؟ کدام را ترجیح می‌دهی و چرا؟
   . اکسیوس یک پکیج هست و فچ یک تابع داخلیه. مدیریت خطا http در axios خیلی راحت تره. در کل axios رو ترجیح میدم چون هم مدیریت خطا توش راحته و سینتکسش خواناتره به نسبت.
     

## 8. فرض کن باید یک صفحه داشبورد برای نمایش لیست کاربران بسازی. چه ساختاری برای فایل‌ها در نظر می‌گیری؟
  ```ruby
    src/
    ├──
    ├──Pages/
        ├──Dashboard.tsx
        ├──Loading.tsx
        
    |
    ├──httpClient/
	    └──Index.tsx
	|
	├──Layout/
		├──Index.tsx
		├──userRow.tsx
	├──
  ```
   
## 9. برای جدول کاربران، چه لایبرری‌هایی ممکن است استفاده کنی؟
  .  (برای مرتب‌سازی، صفحه‌بندی، فیلتر و…) </br>
    از لایبرری TanStack Table و AG Grid(اگه نیاز بشه) و shadcn(برای ui). 
   

## 10. چطور کامپوننت‌هایی مثل Modal یا ConfirmDialog را قابل استفاده مجدد می‌سازی؟
   . کاستوم هوکشون میکنم و یا چیزای مورد نیازو از پراپس میگیرم.
    

## 11. فرض کن API کاربران کند است. لیست کاربران با تأخیر نمایش داده می‌شود. چه راهکاری برای UX مناسب‌تر داری؟
    
   . (لودر؟ اسکلتون؟…) </br>
     یک کامپوننت لودینگ میزارم تا موقعی که api قابل دسترسی بشه.
    

## 12. اگر در API خطای 401 یا 403 دریافت کردی، چه برخوردی در UI مناسب است؟
   . خطا رو در قالب یک نوتیفیکیشن میفرستم و یک گزینه تلاش مجدد درونش قرار میدم با لیبرری مثل react-toastify و یا یک کامپوننت درست میکنم و خطارو به اون میفرستم و یک گزینه تلاش مجدد رو میزارم.
    

## 13. فرض کن می‌خواهیم کاربرها را بر اساس نقش‌شان (admin, user) فیلتر کنیم. این فیلتر را کجا و چطور پیاده می‌کنی؟
   . اگه TanStack Table استفاده کنیم فیلترو اونجا اعمال میکنم یا هم یک ابجکت درست میکنم که به تعداد نقش های کاربران مثلا admin یا user خونه داره و درون اون خونه ها ارایه ای از کاربران هستش.
  ```javascript
	 const group = users.reduce(
	   (acc, user) => {
    if (user.role === 'admin') acc.admin.push(user);
    else if (user.role === 'user') acc.user.push(user);
    return acc;
    },
    { admin: [], user: [] });
  ```
   . یا هم با فیلتر
  ```javascript
    const group = {
		admin: users.filter(user => user.role === 'admin') ,
		user: users.filter(user => user.role === 'user')
    };
  ```
    

## 14. آخرین پروژه‌ای که در آن React استفاده کردی چه بود؟ دقیقاً چه بخشی از پروژه را انجام دادی؟
   . تا الان پروژه ای انجام ندادم.
    

## 16. اگر با خطایی مواجه شدی که نمی‌توانی سریع حلش کنی، چه می‌کنی؟ مراحل رسیدگی‌ات را توضیح بده.
   . اول از دنبال ریشه خطا میرم با دیدن لاگ‌ها، DevTools و بررسی کدم متوجه می‌شم خطا کجاست بعد هوش مصنوعی کمک میگیرم اگه نتیجه نداد از دوستان یا ارشد کمک میگیرم.
    

## 17. وقتی که API مستند نشده یا نامشخص است، چطور با تیم backend همکاری می‌کنی؟
   . از فایل .env استفاده میکنم برای url و چیزایی که ممکنه تغییر کنه و برای تیم بک اند شیر میکنم و یا یک داکیومنت ساده مینویسم برای این موضوع.
    

